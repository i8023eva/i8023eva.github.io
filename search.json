[{"title":"Me？","url":"/2018/03/05/README/","content":"\n　 <!-- more -->\n\n`Email`：i8023eva@163.com\n\nObjective-C  &&  Swift  \n\nhttps://github.com/i8023eva\n","tags":["about"]},{"title":"原码反码补码","url":"/2016/12/29/2019-5-10-原码反码补码/","content":"\n> \n$$ 正数^原 = 正数^反 = 正数^补 $$  \n$负数^反 = 负数^原$符号位不变,其余按位取反  \n$负数^补 = 负数^反$+1\n\n# 1. 原码\n0按8位来看  \n$[+0]^原 = 0　0000000$  \n$[-0]^原 = 1　0000000$  \n0的原码表示不唯一\n\n# 2. 反码\n$[+0]^反 = 0　0000000$  \n$[-0]^反 = 1　1111111$  \n0的反码表示也是不唯一的\n\n# 3. 补码\n$[+0]^补 = 0　0000000$  \n$[-0]^补 = [-0]^反 + 1 = 1,0000,0000$  \n对于8位字长,进位的1溢出,我们只能看到8个0,这就和+0是一样的.  \n> 补码解决了0的表示不唯一的问题.\n\n## 3.1 补码的算术运算\n> 通过引进补码,可将减法运算转换为加法运算.\n\n$[X+Y]^补 = [X]^补 + [Y]^补$\n$[X-Y]^补 = [X+(-Y)]^补 = [X]^补 + [-Y]^补$\n\n*例1*　66 - 51 = 66 + (-51) = 15\n\n用二进制补码运算 : \n$[+66]^补 = [+66]^原 = 01000010$  \n$[-51]^原 = 1　0110011$  \n$[-51]^补 = 1　1001101$  \n$[+66]^补 + [-51]^补 = 1，0000，1111$  \n$=15$  \n\n*例2*　X = -52 = -0110100, Y = 116 = +1110100, 求 X + Y = ?\n\n$[X]^原 = 10110100$  \n$[X]^补 = 11001100$  \n$[Y]^补 = 01110100$  \n$[X + Y]^补 = 01000000$  \nX + Y = +1000000\n\n### 3.1.1 溢出问题\n> 除法运算溢出时,产生'除数为0'中断\n乘法运算无溢出问题\n\n*例3* 若 : X = 0111 1000, Y = 0110 1001　则 : X + Y = 1110 0001\n\n如果是有符号数,次高位向最高位有进位, 而最高位向前无进位,产生溢出(两个正数相加变成负数).  \n如果是无符号数,就不算溢出,因为最高位向更高位没有进位.\n\n## 3.2 补码的说明\n> 正数不变,负数即用模减去绝对值.\n\n### 3.2.1 特殊数 10000000\n对无符号数 :  \n$(10000000)_B = 128$  \n在原码中定义为 :  \n$(10000000)_B = -0$  \n在反码中定义为 :  \n$(10000000)_B = -127$  \n在补码中定义为 :  \n$(10000000)_B = -128$\n\n### 3.2.2 关于模\n说一个钟表的例子:  \n　将指针从5点拨到1点;  \n　两种拨法:  \n　　逆时针: 5 - 4 = 1;  \n　　顺时针: 5 + 8 = 12 + 1 = 1;  \n　这是模12:  \n　　5 - 4 = 5 + 8 → 8为4的补数  \n　　$[-4]^补 = 12 - 4 = 8$\n\n> 二进制下，有多少位数参加运算,模就是在 1 的后面加上多少个 0.\n\n### 3.2.3 -128的补码\n 有符号 | 无符号 | 二进制补码\n ------ | ------ | ----------\n 0      | 0      | 0000 0000\n 1      | 1      | 0000 0001\n ...    | ...    | ...\n 127    | 127    | 0111 1111\n有符号的从这里开始变化  \n\n -128   | 128    | 1000 0000\n ------ | ------ | ----------\n -127   | 129    | 1000 0001\n ...    | ...    | ...\n -1     | 255    | 1111 1111\n 0      | 0      | 0000 0000\n\n补码没有+0/-0之分,所以这个特殊的数就用-128来表示.  \n就像钟表例子一样,这就是一个环,超出之后其实又从0开始计算超出的部分.\n  \n用模来算的话 :  \n八位二进制的模 : 1 0000 0000;  \n-128的绝对值 : 1 000 0000  \n-128的补码 : 10000 0000 - 1000 0000 = 1000 0000  \n\n负数的补码等于反码加一  \n=> 1 0000 0000 - 1000 0000  \n=> (1111 1111 - 0000 0001) - 1000 0000  \n=> 1111 1111 - 1000 0000 + 1  \n=> 0111 1111 + 1  \n\n## 3.3 补码转换为十进制\n负数 => 对补码再取补  \n\n$[X]^补 = 1101 0010$  \n$X = [[X]^补]^补 = [1101 0010]^补 = 1010 1110 = -46$  \n\n---\nB , Binary (二进制);\nH , Hex (十六进制);\nO , Octal (八进制);\nD , Decimal (十进制).\n"}]