[{"title":"动态规划","url":"/2019/07/10/动态规划/","content":"\n## 数字三角形\n\n给出一个数字三角形。从三角形的顶部到底部有很多条不同的路径。对于每条路径，把路径上面的数加起来可以得到一个和，你的任务就是找到最大的和。\n 注意：路径上的每一步只能从一个数走到下一层上和它最近的左边的那个数或者右边的那个数。\n ![1](https://github.com/i8023eva/i8023eva.github.io/blob/master/2019/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.png?raw=true) \n \n 输入  \n 输入的是一行是一个整数N (1 < N <= 100)，给出三角形的行数。下面的N行给出数字三角形。数字三角形上的数的范围都在0和100之间。  \n 输出  \n 输出最大的和。\n >  \n 样例输入  \n 5  \n 7  \n 3 8    \n 8 1 0    \n 2 7 4 4    \n 4 5 2 6 5    \n 样例输出  \n 30  \n  \n```c++\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define MAX 101\n\nint D[MAX][MAX];\nint n;\n\nint maxSum(int i, int j) {\n    if (i == n) {\n        return D[i][j]; //最后一行\n    }\n    int x = maxSum(i + 1, j);\n    int y = maxSum(i + 1, j + 1); //下一行最近的两个值\n    return max(x, y) + D[i][j];\n}\n\nint main(int argc, const char * argv[]) {\n    int i, j;\n    cin >> n;\n    \n    for (i = 1; i <= n; i++) {\n        for (j = 1; j <= i; j++) {\n            cin >> D[i][j];\n        }\n    }\n    cout << maxSum(1, 1) << endl;\n    \n    return 0;\n}\n \n```  \n\n递归会产生重复计算,时间复杂度为 2<sup>n</sup>，n = 100行，会超时。\n![2](https://github.com/i8023eva/i8023eva.github.io/blob/master/2019/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2.png?raw=true)  \n\n创建 maxSum(i,j)保存值，用初值去重。有几个数字计算几次，时间复杂度n(n+1)/2 (n<sup>2</sup>)，把结果存起来就成了动归程序。  \n  \n```c++  \nint D[MAX][MAX];\nint MaxSum[MAX][MAX];\nint n;\n\nint maxSum(int i, int j) {\n    if (MaxSum[i][j] != -1) { //已经算过了\n        return MaxSum[i][j];\n    }\n    if (i == n) {\n        MaxSum[i][j] = D[i][j]; //最后一行\n    }\n    int x = maxSum(i + 1, j);\n    int y = maxSum(i + 1, j + 1); //下一行最近的两个的大值\n    MaxSum[i][j] = max(x, y) + D[i][j];\n    return MaxSum[i][j];\n}\n\nint main(int argc, const char * argv[]) {\n    int i, j;\n    cin >> n;\n    \n    for (i = 1; i <= n; i++) {\n        for (j = 1; j <= i; j++) {\n            cin >> D[i][j];\n            MaxSum[i][j] = -1;//初值 -1\n        }\n    }\n    cout << maxSum(1, 1) << endl;\n    \n    return 0;\n}\n```\n  \n### 递归转成递推  \n\n![3](https://github.com/i8023eva/i8023eva.github.io/blob/master/2019/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/3.png?raw=true)  \n\n```c++\nfor (int i = 1; i <= n ; i++) {\n        MaxSum[n][i] = D[n][i];//为最后一行赋值\n    }\n    for (int i = n - 1; i >= 1; i--) { //从倒第二行开始\n        for (int j = 1; j <= i; j++) {\n            MaxSum[i][j] = max(MaxSum[i + 1][j], MaxSum[i + 1][j + 1]) + D[i][j];\n        }\n    }\n```\n\n### 空间优化  \n\n![4](https://github.com/i8023eva/i8023eva.github.io/blob/master/2019/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/4.png?raw=true)\n  \n```c++\nint D[MAX][MAX];\nint n;\nint * MaxSum;\n\nint main(int argc, const char * argv[]) {\n    int i,j;\n    cin >> n;\n    for (i = 1; i <= n; i++) {\n        for (j = 1; j <= i; j++) {\n            cin >> D[i][j];\n        }\n    }\n    MaxSum = D[n];//指向第 n 行\n    for (int i = n - 1; i >= 1; i--) {\n        for (int j = 1; j <= i; j++) {\n            MaxSum[j] = max(MaxSum[j], MaxSum[j + 1]) + D[i][j];\n        }\n    }\n    cout << MaxSum[1] << endl;\n    \n    return 0;\n}\n```  \n\n## 最长上升子序列\n\n一个数的序列ai，当a1 < a2 < ... < aS的时候，我们称这个序 列是上升的。对于给定的一个\n 序列(a1, a2, ..., aN)，我们可以得到 一些上升的子序列(ai1, ai2, ..., aiK)，\n 这里1 <= i1 < i2 < ... < iK <= N。比如，对于序列(1, 7, 3, 5, 9, 4, 8)，有它的\n 一些上升子 序列，如(1, 7), (3, 4, 8)等等。这些子序列中最长的长度是4，比 如\n 子序列(1, 3, 5, 8).你的任务，就是对于给定的序列，求出最长上升子序列的长度。\n\n输入数据\n输入的第一行是序列的长度N (1 <= N <= 1000)。第二行给\n 出序列中的N个整数，这些整数的取值范围都在0到10000。\n输出要求\n最长上升子序列的长度。\n> \n输入样例  \n7   \n1 7 3 5 9 4 8   \n输出样例  \n4  \n  \n### 分解子问题\n\n求以a<sub>k</sub>(k=1, 2, 3...N)为终点的最长上升子序列的长度  \n一个上升子序列中最右边的那个数，称为该子序列的 “终点”。  \n那么这N个子问题的解中，最大的那个就是整个问题的解。  \n子问题只和一个变量-- 数字的位置相关。因此序列中数的位置k就是“状态”，而状态\nk对应的“值”，就是以a<sub>k</sub>做为 “终点”的最长上升子序列的长度。  \n状态一共有N个。  \n\n### 找出状态转移方程\n\nmaxLen(k)表示以a<sub>k</sub>做为“终点”的最长上升子序列的长度。  \n初始状态:`maxLen(1) = 1`  \nmaxLen(k) = max{ maxLen(i): 1<= i < k 且 a<sub>i</sub> < a<sub>k</sub>且 k≠1 } + 1  \nmaxLen(k)的值，就是在a<sub>k</sub>左边(a<sub>1</sub>~a<sub>k-1</sub>中最长的子序列长度)，“终点”数值小于a<sub>k</sub> ，且长度\n最大的那个上升子序列的长度再加1(加上a<sub>k</sub>)。因为a<sub>k</sub>左边任何“终点”小于a<sub>k</sub>的子序列，加上a<sub>k</sub>后就能形成一个更长的上升子序列。  \n\n```c++\nconst int MAX = 1000;\nint a[MAX];\nint maxLen[MAX];\n\nint main(int argc, const char * argv[]) {\n    int n;\n    cin >> n;\n    \n    for (int i = 1; i <= n; ++i) {\n        cin >> a[i];\n        maxLen[i] = 1;\n    }\n    // 每个运算花费o(n) * n  >> 时间复杂度O(N^2)\n    for (int i = 2; i <= n; ++i) {\n        for (int j = 1; j < i; ++j) { // a[i]左边所有的数比较\n            if (a[i] > a[j]) { //a[i]大，在a[j]的基础上要加上 a[i]就是最长\n                maxLen[i] = max(maxLen[i], maxLen[j] + 1); \n                // max[i]不能直接等于 max[j] +1，max[i]在更新，可能前面会有更大值，所以需要和当前 max[i]比较\n            } //如果前面没有比 a[i]小的，max之前赋值的 1\n        }\n    }\n    cout << * max_element(maxLen + 1, maxLen + n + 1);\n    \n    return 0;\n}\n```  \n\n## 最长公共子序列\n\n给出两个字符串，求出这样的一 个最长的公共子序列的长度:  \n子序列中的每个字符都能在两个原串中找到， 而且每个字符的先后顺序和原串中的先后顺序一致。  \n>\nSample Input  \n>\nabcfbc abfcab  \nprogramming contest  \nabcd mnp  \n>\nSample Output  \n4  \n2  \n0  \n  \n输入两个串s1,s2, 设MaxLen(i,j)表示:  \ns1的左边i个字符形成的子串，与s2左边的j个 字符形成的子串的最长公共子序列的长度(i,j从0 开始算)  \nMaxLen(i,j) 就是本题的“状态”  \n假定 len1 = strlen(s1),len2 = strlen(s2)  \n那么题目就是要求 MaxLen(len1,len2)  \n  \n显然:  \n\n```\nMaxLen(n,0) = 0 ( n= 0...len1)  \nMaxLen(0,n) = 0 ( n= 0...len2)  \n时间复杂度O(mn) m,n是两个字串长度\n```  \n\n边界值,s1的 n 个元素和s2的 0 个元素,显然不能比较，数量为 0  \n\n递推公式:  \n\n```c++\nif ( s1[i-1] == s2[j-1] ) //s1的最左边字符是s1[0]\nMaxLen(i,j) = MaxLen(i-1,j-1) + 1;\n//s1 左边 i 个元素，s2 左边 j 个元素所形成的的最长公共子序列的长度，\n//是 s1 的左边 i-1 个元素，s2 左边 j-1 个元素的长度+1，\n//因为 s1 的第 i 个元素s1[i-1]和 s2 的第 j 个元素s2[j-1]是相等的，所以在这个 \n//max(i-1,j-1)个长度上+1；  \nelse\nMaxLen(i,j) = Max(MaxLen(i,j-1),MaxLen(i-1,j) );  \n```  \n\n![5](https://github.com/i8023eva/i8023eva.github.io/blob/master/2019/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/5.png?raw=true)  \n```\ns1[i-1] != s2[j-1]时，MaxLen(i,j) = Max(MaxLen(i,j-1),MaxLen(i-1,j) );  \n```\nMaxLen(S1,S2)不会比MaxLen(S<sub>1</sub>,S2<sub>j-1</sub>)和 MaxLen(S1<sub>i-1</sub>,S2)两者之中任何一个小，也不会比两者都大。  \n反证法：  \n假设MaxLen(S1,S2)比MaxLen(S1,S2<sub>j-1</sub>)大，也就是说s2[j-1]是有效的，属于最长公共子序列，且是 S1 的最后一个值；  \n假设MaxLen(S1,S2)比MaxLen(S1<sub>i-1</sub>,S2)大，也就是说s1[i-1]是有效的，属于最长公共子序列，且是 S2 的最后一个值；  \n也就是说s1[i-1] = s2[j-1]的，但前提是s1[i-1] != s2[j-1]，所以比他俩都大不成立  \n\n\n\n\n\n\n\n\n\n\n \n \n \n \n ","tags":["算法"]},{"title":"原码反码补码","url":"/2016/12/29/2019-5-10-原码反码补码/","content":"\n> 正数<sup>原</sup> = 正数<sup>反</sup> = 正数<sup>补</sup>  \n> 负数<sup>反</sup> = 负数<sup>原</sup>　符号位不变,其余按位取反   \n> 负数<sup>补</sup> = 负数<sup>反</sup>+1  \n\n# 1. 原码\n0按8位来看  \n[+0]<sup>原</sup> = 0　0000000  \n[-0]<sup>原</sup> = 1　0000000  \n0的原码表示不唯一\n\n# 2. 反码\n[+0]<sup>反</sup> = 0　0000000  \n[-0]<sup>反</sup> = 1　1111111  \n0的反码表示也是不唯一的\n\n# 3. 补码\n[+0]<sup>补</sup> = 0　0000000  \n[-0]<sup>补</sup> = [-0]<sup>反</sup> + 1 = 1,0000,0000  \n对于8位字长,进位的1溢出,我们只能看到8个0,这就和+0是一样的.  \n> 补码解决了0的表示不唯一的问题.\n\n## 3.1 补码的算术运算\n> 通过引进补码,可将减法运算转换为加法运算.\n\n[X+Y]<sup>补</sup> = [X]<sup>补</sup> + [Y]<sup>补</sup>\n[X-Y]<sup>补</sup> = [X+(-Y)]<sup>补</sup> = [X]<sup>补</sup> + [-Y]<sup>补</sup>\n\n*例1*　66 - 51 = 66 + (-51) = 15\n\n用二进制补码运算 : \n[+66]<sup>补</sup> = [+66]<sup>原</sup> = 01000010  \n[-51]<sup>原</sup> = 1　0110011  \n[-51]<sup>补</sup> = 1　1001101  \n[+66]<sup>补</sup> + [-51]<sup>补</sup> = 1,0000,1111  \n=15  \n\n*例2*　X = -52 = -0110100, Y = 116 = +1110100, 求 X + Y = ?\n\n[X]<sup>原</sup> = 10110100  \n[X]<sup>补</sup> = 11001100  \n[Y]<sup>补</sup> = 01110100  \n[X + Y]<sup>补</sup> = 01000000  \nX + Y = +1000000\n\n### 3.1.1 溢出问题\n> 除法运算溢出时,产生`除数为0`中断  \n乘法运算无溢出问题\n\n*例3* 若 : X = 0111 1000, Y = 0110 1001　则 : X + Y = 1110 0001\n\n如果是有符号数,次高位向最高位有进位, 而最高位向前无进位,产生溢出(两个正数相加变成负数).  \n如果是无符号数,就不算溢出,因为最高位向更高位没有进位.\n\n## 3.2 补码的说明\n> 正数不变,负数即用模减去绝对值.\n\n### 3.2.1 特殊数 10000000\n对无符号数 :  \n(10000000)_B = 128  \n在原码中定义为 :  \n(10000000)_B = -0  \n在反码中定义为 :  \n(10000000)_B = -127  \n在补码中定义为 :  \n(10000000)_B = -128\n\n### 3.2.2 关于模\n说一个钟表的例子:  \n　将指针从5点拨到1点;  \n　两种拨法:  \n　　逆时针: 5 - 4 = 1;  \n　　顺时针: 5 + 8 = 12 + 1 = 1;  \n　这是模12:  \n　　5 - 4 = 5 + 8 → 8为4的补数  \n　　[-4]<sup>补</sup> = 12 - 4 = 8\n\n> 二进制下，有多少位数参加运算,模就是在 1 的后面加上多少个 0.\n\n### 3.2.3 -128的补码\n 有符号  | 无符号  | 二进制补码\n :-----:| :-----:| :---------:\n 0      | 0      | 0000 0000\n 1      | 1      | 0000 0001\n ...    | ...    | ...\n 127    | 127    | 0111 1111\n有符号的从这里开始变化  \n\n -128   | 128    | 1000 0000\n :-----:| :-----:| :---------:\n -127   | 129    | 1000 0001\n ...    | ...    | ...\n -1     | 255    | 1111 1111\n 0      | 0      | 0000 0000\n\n补码没有+0/-0之分,所以这个特殊的数就用-128来表示.  \n就像钟表例子一样,这就是一个环,超出之后其实又从0开始计算超出的部分.\n  \n用模来算的话 :  \n八位二进制的模 : 1 0000 0000;  \n-128的绝对值 : 1 000 0000  \n-128的补码 : 10000 0000 - 1000 0000 = 1000 0000  \n\n负数的补码等于反码加一  \n=> 1 0000 0000 - 1000 0000  \n=> (1111 1111 - 0000 0001) - 1000 0000  \n=> 1111 1111 - 1000 0000 + 1  \n=> 0111 1111 + 1  \n\n## 3.3 补码转换为十进制\n负数 => 对补码再取补  \n\n[X]<sup>补 = 1101 0010  \nX = [[X]<sup>补</sup>]<sup>补</sup> = [1101 0010]<sup>补</sup> = 1010 1110 = -46  \n\n---\nB , Binary (二进制);  \nH , Hex (十六进制);  \nO , Octal (八进制);  \nD , Decimal (十进制).  \n"}]