[{"title":"动态规划","url":"/2019/07/10/动态规划/","content":"\n 图1给出了一个数字三角形。从三角形的顶部到底部有很多条不同的路径。对于每条路径，把路径上面的数加起来可以得到一个和，你的任务就是找到最大的和。\n 注意：路径上的每一步只能从一个数走到下一层上和它最近的左边的那个数或者右边的那个数。\n ![图1](https://github.com/i8023eva/i8023eva.github.io/blob/master/2019/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-07-10%2014.07.30.png?raw=true) \n \n 输入  \n 输入的是一行是一个整数N (1 < N <= 100)，给出三角形的行数。下面的N行给出数字三角形。数字三角形上的数的范围都在0和100之间。  \n 输出  \n 输出最大的和。\n >  \n 样例输入  \n 5  \n 7  \n 3 8    \n 8 1 0    \n 2 7 4 4    \n 4 5 2 6 5    \n 样例输出  \n 30  \n \n \n \n ```c++\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define MAX 101\n\nint D[MAX][MAX];\nint n;\n\nint maxSum(int i, int j) {\n    if (i == n) {\n        return D[i][j]; //最后一行\n    }\n    int x = maxSum(i + 1, j);\n    int y = maxSum(i + 1, j + 1); //下一行最近的两个值\n    return max(x, y) + D[i][j];\n}\n\nint main(int argc, const char * argv[]) {\n    int i, j;\n    cin >> n;\n    \n    for (i = 1; i <= n; i++) {\n        for (j = 1; j <= i; j++) {\n            cin >> D[i][j];\n        }\n    }\n    cout << maxSum(1, 1) << endl;\n    \n    return 0;\n}\n \n ```\n \n递归会产生重复计算  \n![2](https://github.com/i8023eva/i8023eva.github.io/blob/master/2019/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-07-10%2014.07.30%202.png?raw=true)  \n时间复杂度为 2<sup>n</sup>，n = 100行，会超时。  \n创建 maxSum(i,j)保存值，用初值去重。有几个数字计算几次，时间复杂度n(n+1)/2，把结果存起来就成了动归程序。  \n\n```c++\nint D[MAX][MAX];\nint MaxSum[MAX][MAX];\nint n;\n\nint maxSum(int i, int j) {\n    if (MaxSum[i][j] != -1) { //已经算过了\n        return MaxSum[i][j];\n    }\n    if (i == n) {\n        MaxSum[i][j] = D[i][j]; //最后一行\n    }\n    int x = maxSum(i + 1, j);\n    int y = maxSum(i + 1, j + 1); //下一行最近的两个的大值\n    MaxSum[i][j] = max(x, y) + D[i][j];\n    return MaxSum[i][j];\n}\n\nint main(int argc, const char * argv[]) {\n    int i, j;\n    cin >> n;\n    \n    for (i = 1; i <= n; i++) {\n        for (j = 1; j <= i; j++) {\n            cin >> D[i][j];\n            MaxSum[i][j] = -1;//初值 -1\n        }\n    }\n    cout << maxSum(1, 1) << endl;\n    \n    return 0;\n}\n```\n  \n### 递归转成递推  \n\n![3](https://github.com/i8023eva/i8023eva.github.io/blob/master/2019/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-07-10%2014.49.33.png?raw=true)\n```c++\nfor (int i = 1; i <= n ; i++) {\n        MaxSum[n][i] = D[n][i];//为最后一行赋值\n    }\n    for (int i = n - 1; i >= 1; i--) { //从倒第二行开始\n        for (int j = 1; j <= i; j++) {\n            MaxSum[i][j] = max(MaxSum[i + 1][j], MaxSum[i + 1][j + 1]) + D[i][j];\n        }\n    }\n```\n\n### 空间优化  \n\n![4](https://github.com/i8023eva/i8023eva.github.io/blob/master/2019/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-07-10%2015.04.40.png?raw=true)\n\n```c++\nint D[MAX][MAX];\nint n;\nint * MaxSum;\n\nint main(int argc, const char * argv[]) {\n    int i,j;\n    cin >> n;\n    for (i = 1; i <= n; i++) {\n        for (j = 1; j <= i; j++) {\n            cin >> D[i][j];\n        }\n    }\n    MaxSum = D[n];//指向第 n 行\n    for (int i = n - 1; i >= 1; i--) {\n        for (int j = 1; j <= i; j++) {\n            MaxSum[j] = max(MaxSum[j], MaxSum[j + 1]) + D[i][j];\n        }\n    }\n    cout << MaxSum[1] << endl;\n    \n    return 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n ","tags":["算法"]},{"title":"原码反码补码","url":"/2016/12/29/2019-5-10-原码反码补码/","content":"\n> 正数<sup>原</sup> = 正数<sup>反</sup> = 正数<sup>补</sup>  \n> 负数<sup>反</sup> = 负数<sup>原</sup>　符号位不变,其余按位取反   \n> 负数<sup>补</sup> = 负数<sup>反</sup>+1  \n\n# 1. 原码\n0按8位来看  \n[+0]<sup>原</sup> = 0　0000000  \n[-0]<sup>原</sup> = 1　0000000  \n0的原码表示不唯一\n\n# 2. 反码\n[+0]<sup>反</sup> = 0　0000000  \n[-0]<sup>反</sup> = 1　1111111  \n0的反码表示也是不唯一的\n\n# 3. 补码\n[+0]<sup>补</sup> = 0　0000000  \n[-0]<sup>补</sup> = [-0]<sup>反</sup> + 1 = 1,0000,0000  \n对于8位字长,进位的1溢出,我们只能看到8个0,这就和+0是一样的.  \n> 补码解决了0的表示不唯一的问题.\n\n## 3.1 补码的算术运算\n> 通过引进补码,可将减法运算转换为加法运算.\n\n[X+Y]<sup>补</sup> = [X]<sup>补</sup> + [Y]<sup>补</sup>\n[X-Y]<sup>补</sup> = [X+(-Y)]<sup>补</sup> = [X]<sup>补</sup> + [-Y]<sup>补</sup>\n\n*例1*　66 - 51 = 66 + (-51) = 15\n\n用二进制补码运算 : \n[+66]<sup>补</sup> = [+66]<sup>原</sup> = 01000010  \n[-51]<sup>原</sup> = 1　0110011  \n[-51]<sup>补</sup> = 1　1001101  \n[+66]<sup>补</sup> + [-51]<sup>补</sup> = 1,0000,1111  \n=15  \n\n*例2*　X = -52 = -0110100, Y = 116 = +1110100, 求 X + Y = ?\n\n[X]<sup>原</sup> = 10110100  \n[X]<sup>补</sup> = 11001100  \n[Y]<sup>补</sup> = 01110100  \n[X + Y]<sup>补</sup> = 01000000  \nX + Y = +1000000\n\n### 3.1.1 溢出问题\n> 除法运算溢出时,产生`除数为0`中断  \n乘法运算无溢出问题\n\n*例3* 若 : X = 0111 1000, Y = 0110 1001　则 : X + Y = 1110 0001\n\n如果是有符号数,次高位向最高位有进位, 而最高位向前无进位,产生溢出(两个正数相加变成负数).  \n如果是无符号数,就不算溢出,因为最高位向更高位没有进位.\n\n## 3.2 补码的说明\n> 正数不变,负数即用模减去绝对值.\n\n### 3.2.1 特殊数 10000000\n对无符号数 :  \n(10000000)_B = 128  \n在原码中定义为 :  \n(10000000)_B = -0  \n在反码中定义为 :  \n(10000000)_B = -127  \n在补码中定义为 :  \n(10000000)_B = -128\n\n### 3.2.2 关于模\n说一个钟表的例子:  \n　将指针从5点拨到1点;  \n　两种拨法:  \n　　逆时针: 5 - 4 = 1;  \n　　顺时针: 5 + 8 = 12 + 1 = 1;  \n　这是模12:  \n　　5 - 4 = 5 + 8 → 8为4的补数  \n　　[-4]<sup>补</sup> = 12 - 4 = 8\n\n> 二进制下，有多少位数参加运算,模就是在 1 的后面加上多少个 0.\n\n### 3.2.3 -128的补码\n 有符号  | 无符号  | 二进制补码\n :-----:| :-----:| :---------:\n 0      | 0      | 0000 0000\n 1      | 1      | 0000 0001\n ...    | ...    | ...\n 127    | 127    | 0111 1111\n有符号的从这里开始变化  \n\n -128   | 128    | 1000 0000\n :-----:| :-----:| :---------:\n -127   | 129    | 1000 0001\n ...    | ...    | ...\n -1     | 255    | 1111 1111\n 0      | 0      | 0000 0000\n\n补码没有+0/-0之分,所以这个特殊的数就用-128来表示.  \n就像钟表例子一样,这就是一个环,超出之后其实又从0开始计算超出的部分.\n  \n用模来算的话 :  \n八位二进制的模 : 1 0000 0000;  \n-128的绝对值 : 1 000 0000  \n-128的补码 : 10000 0000 - 1000 0000 = 1000 0000  \n\n负数的补码等于反码加一  \n=> 1 0000 0000 - 1000 0000  \n=> (1111 1111 - 0000 0001) - 1000 0000  \n=> 1111 1111 - 1000 0000 + 1  \n=> 0111 1111 + 1  \n\n## 3.3 补码转换为十进制\n负数 => 对补码再取补  \n\n[X]<sup>补 = 1101 0010  \nX = [[X]<sup>补</sup>]<sup>补</sup> = [1101 0010]<sup>补</sup> = 1010 1110 = -46  \n\n---\nB , Binary (二进制);  \nH , Hex (十六进制);  \nO , Octal (八进制);  \nD , Decimal (十进制).  \n"}]