<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="i8023eva">
    <meta name="keyword" content="i8023eva">
    <meta name="baidu-site-verification" content="ftkVoqerkN">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        动态规划 - i8023eva的博客 | i8023eva&#39;s Blog
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> alt+shift+k =  </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/avatar.jpg">
        </div>
        <div class="name">
            <i>L</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li>
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li>
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li>
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#数字三角形"><span class="toc-text">数字三角形</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#递归转成递推"><span class="toc-text">递归转成递推</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#空间优化"><span class="toc-text">空间优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最长上升子序列"><span class="toc-text">最长上升子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#分解子问题"><span class="toc-text">分解子问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#找出状态转移方程"><span class="toc-text">找出状态转移方程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最长公共子序列"><span class="toc-text">最长公共子序列</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input">
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> alt+shift+k =  </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        动态规划
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-07-10 13:36:14</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#算法" title="算法">算法</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>

    </div>
    <div class="post-content no-indent">
        <h2 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h2><p>给出一个数字三角形。从三角形的顶部到底部有很多条不同的路径。对于每条路径，把路径上面的数加起来可以得到一个和，你的任务就是找到最大的和。<br> 注意：路径上的每一步只能从一个数走到下一层上和它最近的左边的那个数或者右边的那个数。<br> <img src="https://github.com/i8023eva/i8023eva.github.io/blob/master/2019/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.png?raw=true" alt="1"> </p>
<p> 输入<br> 输入的是一行是一个整数N (1 &lt; N &lt;= 100)，给出三角形的行数。下面的N行给出数字三角形。数字三角形上的数的范围都在0和100之间。<br> 输出<br> 输出最大的和。</p>
<blockquote>
<p> 样例输入<br> 5<br> 7<br> 3 8<br> 8 1 0<br> 2 7 4 4<br> 4 5 2 6 5<br> 样例输出<br> 30  </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 101</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> D[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSum</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">        <span class="keyword">return</span> D[i][j]; <span class="comment">//最后一行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x = maxSum(i + <span class="number">1</span>, j);</span><br><span class="line">    <span class="keyword">int</span> y = maxSum(i + <span class="number">1</span>, j + <span class="number">1</span>); <span class="comment">//下一行最近的两个值</span></span><br><span class="line">    <span class="keyword">return</span> max(x, y) + D[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; D[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxSum(<span class="number">1</span>, <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归会产生重复计算,时间复杂度为 2<sup>n</sup>，n = 100行，会超时。<br><img src="https://github.com/i8023eva/i8023eva.github.io/blob/master/2019/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2.png?raw=true" alt="2">  </p>
<p>创建 maxSum(i,j)保存值，用初值去重。有几个数字计算几次，时间复杂度n(n+1)/2 (n<sup>2</sup>)，把结果存起来就成了动归程序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> D[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> MaxSum[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSum</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (MaxSum[i][j] != <span class="number">-1</span>) &#123; <span class="comment">//已经算过了</span></span><br><span class="line">        <span class="keyword">return</span> MaxSum[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">        MaxSum[i][j] = D[i][j]; <span class="comment">//最后一行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x = maxSum(i + <span class="number">1</span>, j);</span><br><span class="line">    <span class="keyword">int</span> y = maxSum(i + <span class="number">1</span>, j + <span class="number">1</span>); <span class="comment">//下一行最近的两个的大值</span></span><br><span class="line">    MaxSum[i][j] = max(x, y) + D[i][j];</span><br><span class="line">    <span class="keyword">return</span> MaxSum[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; D[i][j];</span><br><span class="line">            MaxSum[i][j] = <span class="number">-1</span>;<span class="comment">//初值 -1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxSum(<span class="number">1</span>, <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归转成递推"><a href="#递归转成递推" class="headerlink" title="递归转成递推"></a>递归转成递推</h3><p><img src="https://github.com/i8023eva/i8023eva.github.io/blob/master/2019/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/3.png?raw=true" alt="3">  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n ; i++) &#123;</span><br><span class="line">        MaxSum[n][i] = D[n][i];<span class="comment">//为最后一行赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123; <span class="comment">//从倒第二行开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            MaxSum[i][j] = max(MaxSum[i + <span class="number">1</span>][j], MaxSum[i + <span class="number">1</span>][j + <span class="number">1</span>]) + D[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p><img src="https://github.com/i8023eva/i8023eva.github.io/blob/master/2019/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/4.png?raw=true" alt="4"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> D[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> * MaxSum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; D[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    MaxSum = D[n];<span class="comment">//指向第 n 行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            MaxSum[j] = max(MaxSum[j], MaxSum[j + <span class="number">1</span>]) + D[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; MaxSum[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h2><p>一个数的序列ai，当a1 &lt; a2 &lt; … &lt; aS的时候，我们称这个序 列是上升的。对于给定的一个<br> 序列(a1, a2, …, aN)，我们可以得到 一些上升的子序列(ai1, ai2, …, aiK)，<br> 这里1 &lt;= i1 &lt; i2 &lt; … &lt; iK &lt;= N。比如，对于序列(1, 7, 3, 5, 9, 4, 8)，有它的<br> 一些上升子 序列，如(1, 7), (3, 4, 8)等等。这些子序列中最长的长度是4，比 如<br> 子序列(1, 3, 5, 8).你的任务，就是对于给定的序列，求出最长上升子序列的长度。</p>
<p>输入数据<br>输入的第一行是序列的长度N (1 &lt;= N &lt;= 1000)。第二行给<br> 出序列中的N个整数，这些整数的取值范围都在0到10000。<br>输出要求<br>最长上升子序列的长度。</p>
<blockquote>
</blockquote>
<p>输入样例<br>7<br>1 7 3 5 9 4 8<br>输出样例<br>4  </p>
<h3 id="分解子问题"><a href="#分解子问题" class="headerlink" title="分解子问题"></a>分解子问题</h3><p>求以a<sub>k</sub>(k=1, 2, 3…N)为终点的最长上升子序列的长度<br>一个上升子序列中最右边的那个数，称为该子序列的 “终点”。<br>那么这N个子问题的解中，最大的那个就是整个问题的解。<br>子问题只和一个变量– 数字的位置相关。因此序列中数的位置k就是“状态”，而状态<br>k对应的“值”，就是以a<sub>k</sub>做为 “终点”的最长上升子序列的长度。<br>状态一共有N个。  </p>
<h3 id="找出状态转移方程"><a href="#找出状态转移方程" class="headerlink" title="找出状态转移方程"></a>找出状态转移方程</h3><p>maxLen(k)表示以a<sub>k</sub>做为“终点”的最长上升子序列的长度。<br>初始状态:<code>maxLen(1) = 1</code><br>maxLen(k) = max{ maxLen(i): 1&lt;= i &lt; k 且 a<sub>i</sub> &lt; a<sub>k</sub>且 k≠1 } + 1<br>maxLen(k)的值，就是在a<sub>k</sub>左边(a<sub>1</sub>~a<sub>k-1</sub>中最长的子序列长度)，“终点”数值小于a<sub>k</sub> ，且长度<br>最大的那个上升子序列的长度再加1(加上a<sub>k</sub>)。因为a<sub>k</sub>左边任何“终点”小于a<sub>k</sub>的子序列，加上a<sub>k</sub>后就能形成一个更长的上升子序列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAX];</span><br><span class="line"><span class="keyword">int</span> maxLen[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        maxLen[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每个运算花费o(n) * n  &gt;&gt; 时间复杂度O(N^2)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123; <span class="comment">// a[i]左边所有的数比较</span></span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[j]) &#123; <span class="comment">//a[i]大，在a[j]的基础上要加上 a[i]就是最长</span></span><br><span class="line">                maxLen[i] = max(maxLen[i], maxLen[j] + <span class="number">1</span>); </span><br><span class="line">                <span class="comment">// max[i]不能直接等于 max[j] +1，max[i]在更新，可能前面会有更大值，所以需要和当前 max[i]比较</span></span><br><span class="line">            &#125; <span class="comment">//如果前面没有比 a[i]小的，max之前赋值的 1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; * max_element(maxLen + <span class="number">1</span>, maxLen + n + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p>给出两个字符串，求出这样的一 个最长的公共子序列的长度:<br>子序列中的每个字符都能在两个原串中找到， 而且每个字符的先后顺序和原串中的先后顺序一致。  </p>
<blockquote>
</blockquote>
<p>Sample Input  </p>
<blockquote>
</blockquote>
<p>abcfbc abfcab<br>programming contest<br>abcd mnp  </p>
<blockquote>
</blockquote>
<p>Sample Output<br>4<br>2<br>0  </p>
<p>输入两个串s1,s2, 设MaxLen(i,j)表示:<br>s1的左边i个字符形成的子串，与s2左边的j个 字符形成的子串的最长公共子序列的长度(i,j从0 开始算)<br>MaxLen(i,j) 就是本题的“状态”<br>假定 len1 = strlen(s1),len2 = strlen(s2)<br>那么题目就是要求 MaxLen(len1,len2)  </p>
<p>显然:  </p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MaxLen(n,<span class="number">0</span>) = <span class="number">0</span> ( n= <span class="number">0.</span>..len1)  </span><br><span class="line">MaxLen(<span class="number">0</span>,n) = <span class="number">0</span> ( n= <span class="number">0.</span>..len2)  </span><br><span class="line">时间复杂度O(mn) m,n是两个字串长度</span><br></pre></td></tr></table></figure>
<p>边界值,s1的 n 个元素和s2的 0 个元素,显然不能比较，数量为 0  </p>
<p>递推公式:  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( s1[i<span class="number">-1</span>] == s2[j<span class="number">-1</span>] ) <span class="comment">//s1的最左边字符是s1[0]</span></span><br><span class="line">MaxLen(i,j) = MaxLen(i<span class="number">-1</span>,j<span class="number">-1</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//s1 左边 i 个元素，s2 左边 j 个元素所形成的的最长公共子序列的长度，</span></span><br><span class="line"><span class="comment">//是 s1 的左边 i-1 个元素，s2 左边 j-1 个元素的长度+1，</span></span><br><span class="line"><span class="comment">//因为 s1 的第 i 个元素s1[i-1]和 s2 的第 j 个元素s2[j-1]是相等的，所以在这个 </span></span><br><span class="line"><span class="comment">//max(i-1,j-1)个长度上+1；  </span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">MaxLen(i,j) = Max(MaxLen(i,j<span class="number">-1</span>),MaxLen(i<span class="number">-1</span>,j) );</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/i8023eva/i8023eva.github.io/blob/master/2019/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/5.png?raw=true" alt="5"><br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1[i<span class="number">-1</span>] != s2[j<span class="number">-1</span>]时，MaxLen(<span class="built_in">i</span>,<span class="built_in">j</span>) = Max(MaxLen(<span class="built_in">i</span>,<span class="built_in">j</span><span class="number">-1</span>),MaxLen(<span class="built_in">i</span><span class="number">-1</span>,<span class="built_in">j</span>) );</span><br></pre></td></tr></table></figure></p>
<p>MaxLen(S1,S2)不会比MaxLen(S<sub>1</sub>,S2<sub>j-1</sub>)和 MaxLen(S1<sub>i-1</sub>,S2)两者之中任何一个小，也不会比两者都大。<br>反证法：<br>假设MaxLen(S1,S2)比MaxLen(S1,S2<sub>j-1</sub>)大，也就是说s2[j-1]是有效的，属于最长公共子序列，且是 S1 的最后一个值；<br>假设MaxLen(S1,S2)比MaxLen(S1<sub>i-1</sub>,S2)大，也就是说s1[i-1]是有效的，属于最长公共子序列，且是 S2 的最后一个值；<br>也就是说s1[i-1] = s2[j-1]的，但前提是s1[i-1] != s2[j-1]，所以比他俩都大不成立  </p>

        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src data-src="/img/donate.gif">
        <p> 感谢鼓励 </p>
    </div>
</div>
        
        <br>
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        
        <li>
            <a target="_blank" href="https://github.com/i8023eva">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-github"></i>
                            </span>
            </a>
        </li>
        

        

    </ul>
    
    <p>
        <!--<span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>-->
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>
