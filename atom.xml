<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>i8023_</title>
  <icon>https://www.gravatar.com/avatar/9465fef69c3a71eb915de2eb6009f32e</icon>
  <subtitle>alt+shift+k = </subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-11T09:21:05.138Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>L</name>
    <email>i8023eva@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>动态规划</title>
    <link href="http://yoursite.com/2019/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2019/07/10/动态规划/</id>
    <published>2019-07-10T05:36:14.000Z</published>
    <updated>2019-07-11T09:21:05.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h2><p>给出一个数字三角形。从三角形的顶部到底部有很多条不同的路径。对于每条路径，把路径上面的数加起来可以得到一个和，你的任务就是找到最大的和。<br> 注意：路径上的每一步只能从一个数走到下一层上和它最近的左边的那个数或者右边的那个数。<br> <img src="https://github.com/i8023eva/i8023eva.github.io/blob/master/2019/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.png?raw=true" alt="1"> </p><p> 输入<br> 输入的是一行是一个整数N (1 &lt; N &lt;= 100)，给出三角形的行数。下面的N行给出数字三角形。数字三角形上的数的范围都在0和100之间。<br> 输出<br> 输出最大的和。</p><blockquote><p> 样例输入<br> 5<br> 7<br> 3 8<br> 8 1 0<br> 2 7 4 4<br> 4 5 2 6 5<br> 样例输出<br> 30  </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 101</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> D[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSum</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">        <span class="keyword">return</span> D[i][j]; <span class="comment">//最后一行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x = maxSum(i + <span class="number">1</span>, j);</span><br><span class="line">    <span class="keyword">int</span> y = maxSum(i + <span class="number">1</span>, j + <span class="number">1</span>); <span class="comment">//下一行最近的两个值</span></span><br><span class="line">    <span class="keyword">return</span> max(x, y) + D[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; D[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxSum(<span class="number">1</span>, <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">递归会产生重复计算,时间复杂度为 2&lt;sup&gt;n&lt;/sup&gt;，n = 100行，会超时。</span><br><span class="line">![<span class="number">2</span>](https:<span class="comment">//github.com/i8023eva/i8023eva.github.io/blob/master/2019/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2.png?raw=true)  </span></span><br><span class="line"></span><br><span class="line">创建 maxSum(i,j)保存值，用初值去重。有几个数字计算几次，时间复杂度n(n+<span class="number">1</span>)/<span class="number">2</span> (n&lt;sup&gt;<span class="number">2</span>&lt;/sup&gt;)，把结果存起来就成了动归程序。  </span><br><span class="line">  </span><br><span class="line">```c++  </span><br><span class="line"><span class="keyword">int</span> D[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> MaxSum[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maxSum(<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">    <span class="keyword">if</span> (MaxSum[i][j] != <span class="number">-1</span>) &#123; <span class="comment">//已经算过了</span></span><br><span class="line">        <span class="keyword">return</span> MaxSum[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">        MaxSum[i][j] = D[i][j]; <span class="comment">//最后一行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x = maxSum(i + <span class="number">1</span>, j);</span><br><span class="line">    <span class="keyword">int</span> y = maxSum(i + <span class="number">1</span>, j + <span class="number">1</span>); <span class="comment">//下一行最近的两个的大值</span></span><br><span class="line">    MaxSum[i][j] = max(x, y) + D[i][j];</span><br><span class="line">    <span class="keyword">return</span> MaxSum[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; D[i][j];</span><br><span class="line">            MaxSum[i][j] = <span class="number">-1</span>;<span class="comment">//初值 -1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxSum(<span class="number">1</span>, <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归转成递推"><a href="#递归转成递推" class="headerlink" title="递归转成递推"></a>递归转成递推</h3><p><img src="https://github.com/i8023eva/i8023eva.github.io/blob/master/2019/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/3.png?raw=true" alt="3">  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n ; i++) &#123;</span><br><span class="line">        MaxSum[n][i] = D[n][i];<span class="comment">//为最后一行赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123; <span class="comment">//从倒第二行开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            MaxSum[i][j] = max(MaxSum[i + <span class="number">1</span>][j], MaxSum[i + <span class="number">1</span>][j + <span class="number">1</span>]) + D[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p><img src="https://github.com/i8023eva/i8023eva.github.io/blob/master/2019/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/4.png?raw=true" alt="4"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> D[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> * MaxSum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; D[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    MaxSum = D[n];<span class="comment">//指向第 n 行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            MaxSum[j] = max(MaxSum[j], MaxSum[j + <span class="number">1</span>]) + D[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; MaxSum[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">## 最长上升子序列</span><br><span class="line"></span><br><span class="line">一个数的序列ai，当a1 &lt; a2 &lt; ... &lt; aS的时候，我们称这个序 列是上升的。对于给定的一个</span><br><span class="line"> 序列(a1, a2, ..., aN)，我们可以得到 一些上升的子序列(ai1, ai2, ..., aiK)，</span><br><span class="line"> 这里<span class="number">1</span> &lt;= i1 &lt; i2 &lt; ... &lt; iK &lt;= N。比如，对于序列(<span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">8</span>)，有它的</span><br><span class="line"> 一些上升子 序列，如(<span class="number">1</span>, <span class="number">7</span>), (<span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>)等等。这些子序列中最长的长度是<span class="number">4</span>，比 如</span><br><span class="line"> 子序列(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>).你的任务，就是对于给定的序列，求出最长上升子序列的长度。</span><br><span class="line"></span><br><span class="line">输入数据</span><br><span class="line">输入的第一行是序列的长度N (<span class="number">1</span> &lt;= N &lt;= <span class="number">1000</span>)。第二行给</span><br><span class="line"> 出序列中的N个整数，这些整数的取值范围都在<span class="number">0</span>到<span class="number">10000</span>。</span><br><span class="line">输出要求</span><br><span class="line">最长上升子序列的长度。</span><br><span class="line">&gt; </span><br><span class="line">输入样例  </span><br><span class="line"><span class="number">7</span>   </span><br><span class="line"><span class="number">1</span> <span class="number">7</span> <span class="number">3</span> <span class="number">5</span> <span class="number">9</span> <span class="number">4</span> <span class="number">8</span>   </span><br><span class="line">输出样例  </span><br><span class="line"><span class="number">4</span>  </span><br><span class="line">  </span><br><span class="line">### 分解子问题</span><br><span class="line"></span><br><span class="line">求以a&lt;sub&gt;k&lt;/sub&gt;(k=<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.</span>..N)为终点的最长上升子序列的长度  </span><br><span class="line">一个上升子序列中最右边的那个数，称为该子序列的 “终点”。  </span><br><span class="line">那么这N个子问题的解中，最大的那个就是整个问题的解。  </span><br><span class="line">子问题只和一个变量-- 数字的位置相关。因此序列中数的位置k就是“状态”，而状态</span><br><span class="line">k对应的“值”，就是以a&lt;sub&gt;k&lt;/sub&gt;做为 “终点”的最长上升子序列的长度。  </span><br><span class="line">状态一共有N个。  </span><br><span class="line"></span><br><span class="line">### 找出状态转移方程</span><br><span class="line"></span><br><span class="line">maxLen(k)表示以a&lt;sub&gt;k&lt;/sub&gt;做为“终点”的最长上升子序列的长度。  </span><br><span class="line">初始状态:`maxLen(<span class="number">1</span>) = <span class="number">1</span>`  </span><br><span class="line">maxLen(k) = max&#123; maxLen(i): <span class="number">1</span>&lt;= i &lt; k 且 a&lt;sub&gt;i&lt;/sub&gt; &lt; a&lt;sub&gt;k&lt;/sub&gt;且 k≠<span class="number">1</span> &#125; + <span class="number">1</span>  </span><br><span class="line">maxLen(k)的值，就是在a&lt;sub&gt;k&lt;/sub&gt;左边(a&lt;sub&gt;<span class="number">1</span>&lt;/sub&gt;~a&lt;sub&gt;k<span class="number">-1</span>&lt;/sub&gt;中最长的子序列长度)，“终点”数值小于a&lt;sub&gt;k&lt;/sub&gt; ，且长度</span><br><span class="line">最大的那个上升子序列的长度再加<span class="number">1</span>(加上a&lt;sub&gt;k&lt;/sub&gt;)。因为a&lt;sub&gt;k&lt;/sub&gt;左边任何“终点”小于a&lt;sub&gt;k&lt;/sub&gt;的子序列，加上a&lt;sub&gt;k&lt;/sub&gt;后就能形成一个更长的上升子序列。  </span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAX];</span><br><span class="line"><span class="keyword">int</span> maxLen[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        maxLen[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每个运算花费o(n) * n  &gt;&gt; 时间复杂度O(N^2)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123; <span class="comment">// a[i]左边所有的数比较</span></span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[j]) &#123; <span class="comment">//a[i]大，在a[j]的基础上要加上 a[i]就是最长</span></span><br><span class="line">                maxLen[i] = max(maxLen[i], maxLen[j] + <span class="number">1</span>); </span><br><span class="line">                <span class="comment">// max[i]不能直接等于 max[j] +1，max[i]在更新，可能前面会有更大值，所以需要和当前 max[i]比较</span></span><br><span class="line">            &#125; <span class="comment">//如果前面没有比 a[i]小的，max之前赋值的 1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; * max_element(maxLen + <span class="number">1</span>, maxLen + n + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">## 最长公共子序列</span><br><span class="line"></span><br><span class="line">给出两个字符串，求出这样的一 个最长的公共子序列的长度:  </span><br><span class="line">子序列中的每个字符都能在两个原串中找到， 而且每个字符的先后顺序和原串中的先后顺序一致。  </span><br><span class="line">&gt;</span><br><span class="line">Sample Input  </span><br><span class="line">&gt;</span><br><span class="line">abcfbc abfcab  </span><br><span class="line">programming contest  </span><br><span class="line">abcd mnp  </span><br><span class="line">&gt;</span><br><span class="line">Sample Output  </span><br><span class="line"><span class="number">4</span>  </span><br><span class="line"><span class="number">2</span>  </span><br><span class="line"><span class="number">0</span>  </span><br><span class="line">  </span><br><span class="line">输入两个串s1,s2, 设MaxLen(i,j)表示:  </span><br><span class="line">s1的左边i个字符形成的子串，与s2左边的j个 字符形成的子串的最长公共子序列的长度(i,j从<span class="number">0</span> 开始算)  </span><br><span class="line">MaxLen(i,j) 就是本题的“状态”  </span><br><span class="line">假定 len1 = <span class="built_in">strlen</span>(s1),len2 = <span class="built_in">strlen</span>(s2)  </span><br><span class="line">那么题目就是要求 MaxLen(len1,len2)  </span><br><span class="line">  </span><br><span class="line">显然:</span><br></pre></td></tr></table></figure><p>MaxLen(n,0) = 0 ( n= 0…len1)<br>MaxLen(0,n) = 0 ( n= 0…len2)<br>时间复杂度O(mn) m,n是两个字串长度<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">边界值,s<span class="number">1</span>的 n 个元素和s<span class="number">2</span>的 <span class="number">0</span> 个元素,显然不能比较，数量为 <span class="number">0</span>  </span><br><span class="line"></span><br><span class="line">递推公式:  </span><br><span class="line"></span><br><span class="line">```<span class="keyword">c</span>++</span><br><span class="line">if ( s<span class="number">1</span>[i<span class="number">-1</span>] == s<span class="number">2</span>[j<span class="number">-1</span>] ) //s<span class="number">1</span>的最左边字符是s<span class="number">1</span>[<span class="number">0</span>]</span><br><span class="line">MaxLen(i,j) = MaxLen(i<span class="number">-1</span>,j<span class="number">-1</span>) + <span class="number">1</span><span class="comment">;</span></span><br><span class="line"><span class="comment">//s1 左边 i 个元素，s2 左边 j 个元素所形成的的最长公共子序列的长度，</span></span><br><span class="line"><span class="comment">//是 s1 的左边 i-1 个元素，s2 左边 j-1 个元素的长度+1，</span></span><br><span class="line"><span class="comment">//因为 s1 的第 i 个元素s1[i-1]和 s2 的第 j 个元素s2[j-1]是相等的，所以在这个 </span></span><br><span class="line"><span class="comment">//max(i-1,j-1)个长度上+1；  </span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">MaxLen(i,j) = Max(MaxLen(i,j-1),MaxLen(i-1,j) );  </span></span><br><span class="line"><span class="comment">```  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">![5](https://github.com/i8023eva/i8023eva.github.io/blob/master/2019/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/5.png?raw=true)</span></span><br></pre></td></tr></table></figure></p><p>s1[i-1] != s2[j-1]时，MaxLen(i,j) = Max(MaxLen(i,j-1),MaxLen(i-1,j) );<br><code>`</code><br>MaxLen(S1,S2)不会比MaxLen(S<sub>1</sub>,S2<sub>j-1</sub>)和 MaxLen(S1<sub>i-1</sub>,S2)两者之中任何一个小，也不会比两者都大。<br>反证法：<br>假设MaxLen(S1,S2)比MaxLen(S1,S2<sub>j-1</sub>)大，也就是说s2[j-1]是有效的，属于最长公共子序列，且是 S1 的最后一个值；<br>假设MaxLen(S1,S2)比MaxLen(S1<sub>i-1</sub>,S2)大，也就是说s1[i-1]是有效的，属于最长公共子序列，且是 S2 的最后一个值；<br>也就是说s1[i-1] = s2[j-1]的，但前提是s1[i-1] != s2[j-1]，所以比他俩都大不成立  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数字三角形&quot;&gt;&lt;a href=&quot;#数字三角形&quot; class=&quot;headerlink&quot; title=&quot;数字三角形&quot;&gt;&lt;/a&gt;数字三角形&lt;/h2&gt;&lt;p&gt;给出一个数字三角形。从三角形的顶部到底部有很多条不同的路径。对于每条路径，把路径上面的数加起来可以得到一个和，你的任
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>原码反码补码</title>
    <link href="http://yoursite.com/2016/12/29/2019-5-10-%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81/"/>
    <id>http://yoursite.com/2016/12/29/2019-5-10-原码反码补码/</id>
    <published>2016-12-29T09:31:57.000Z</published>
    <updated>2019-05-10T14:01:04.187Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>正数<sup>原</sup> = 正数<sup>反</sup> = 正数<sup>补</sup><br>负数<sup>反</sup> = 负数<sup>原</sup>　符号位不变,其余按位取反<br>负数<sup>补</sup> = 负数<sup>反</sup>+1  </p></blockquote><h1 id="1-原码"><a href="#1-原码" class="headerlink" title="1. 原码"></a>1. 原码</h1><p>0按8位来看<br>[+0]<sup>原</sup> = 0　0000000<br>[-0]<sup>原</sup> = 1　0000000<br>0的原码表示不唯一</p><h1 id="2-反码"><a href="#2-反码" class="headerlink" title="2. 反码"></a>2. 反码</h1><p>[+0]<sup>反</sup> = 0　0000000<br>[-0]<sup>反</sup> = 1　1111111<br>0的反码表示也是不唯一的</p><h1 id="3-补码"><a href="#3-补码" class="headerlink" title="3. 补码"></a>3. 补码</h1><p>[+0]<sup>补</sup> = 0　0000000<br>[-0]<sup>补</sup> = [-0]<sup>反</sup> + 1 = 1,0000,0000<br>对于8位字长,进位的1溢出,我们只能看到8个0,这就和+0是一样的.  </p><blockquote><p>补码解决了0的表示不唯一的问题.</p></blockquote><h2 id="3-1-补码的算术运算"><a href="#3-1-补码的算术运算" class="headerlink" title="3.1 补码的算术运算"></a>3.1 补码的算术运算</h2><blockquote><p>通过引进补码,可将减法运算转换为加法运算.</p></blockquote><p>[X+Y]<sup>补</sup> = [X]<sup>补</sup> + [Y]<sup>补</sup><br>[X-Y]<sup>补</sup> = [X+(-Y)]<sup>补</sup> = [X]<sup>补</sup> + [-Y]<sup>补</sup></p><p><em>例1</em>　66 - 51 = 66 + (-51) = 15</p><p>用二进制补码运算 :<br>[+66]<sup>补</sup> = [+66]<sup>原</sup> = 01000010<br>[-51]<sup>原</sup> = 1　0110011<br>[-51]<sup>补</sup> = 1　1001101<br>[+66]<sup>补</sup> + [-51]<sup>补</sup> = 1,0000,1111<br>=15  </p><p><em>例2</em>　X = -52 = -0110100, Y = 116 = +1110100, 求 X + Y = ?</p><p>[X]<sup>原</sup> = 10110100<br>[X]<sup>补</sup> = 11001100<br>[Y]<sup>补</sup> = 01110100<br>[X + Y]<sup>补</sup> = 01000000<br>X + Y = +1000000</p><h3 id="3-1-1-溢出问题"><a href="#3-1-1-溢出问题" class="headerlink" title="3.1.1 溢出问题"></a>3.1.1 溢出问题</h3><blockquote><p>除法运算溢出时,产生<code>除数为0</code>中断<br>乘法运算无溢出问题</p></blockquote><p><em>例3</em> 若 : X = 0111 1000, Y = 0110 1001　则 : X + Y = 1110 0001</p><p>如果是有符号数,次高位向最高位有进位, 而最高位向前无进位,产生溢出(两个正数相加变成负数).<br>如果是无符号数,就不算溢出,因为最高位向更高位没有进位.</p><h2 id="3-2-补码的说明"><a href="#3-2-补码的说明" class="headerlink" title="3.2 补码的说明"></a>3.2 补码的说明</h2><blockquote><p>正数不变,负数即用模减去绝对值.</p></blockquote><h3 id="3-2-1-特殊数-10000000"><a href="#3-2-1-特殊数-10000000" class="headerlink" title="3.2.1 特殊数 10000000"></a>3.2.1 特殊数 10000000</h3><p>对无符号数 :<br>(10000000)_B = 128<br>在原码中定义为 :<br>(10000000)_B = -0<br>在反码中定义为 :<br>(10000000)_B = -127<br>在补码中定义为 :<br>(10000000)_B = -128</p><h3 id="3-2-2-关于模"><a href="#3-2-2-关于模" class="headerlink" title="3.2.2 关于模"></a>3.2.2 关于模</h3><p>说一个钟表的例子:<br>　将指针从5点拨到1点;<br>　两种拨法:<br>　　逆时针: 5 - 4 = 1;<br>　　顺时针: 5 + 8 = 12 + 1 = 1;<br>　这是模12:<br>　　5 - 4 = 5 + 8 → 8为4的补数<br>　　[-4]<sup>补</sup> = 12 - 4 = 8</p><blockquote><p>二进制下，有多少位数参加运算,模就是在 1 的后面加上多少个 0.</p></blockquote><h3 id="3-2-3-128的补码"><a href="#3-2-3-128的补码" class="headerlink" title="3.2.3 -128的补码"></a>3.2.3 -128的补码</h3><table><thead><tr><th style="text-align:center">有符号</th><th style="text-align:center">无符号</th><th style="text-align:center">二进制补码</th></tr></thead><tbody><tr><td style="text-align:center"> 0</td><td style="text-align:center">0</td><td style="text-align:center">0000 0000</td></tr><tr><td style="text-align:center"> 1</td><td style="text-align:center">1</td><td style="text-align:center">0000 0001</td></tr><tr><td style="text-align:center"> …</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr><tr><td style="text-align:center"> 127</td><td style="text-align:center">127</td><td style="text-align:center">0111 1111</td></tr></tbody></table><p>有符号的从这里开始变化  </p><table><thead><tr><th style="text-align:center">-128</th><th style="text-align:center">128</th><th style="text-align:center">1000 0000</th></tr></thead><tbody><tr><td style="text-align:center"> -127</td><td style="text-align:center">129</td><td style="text-align:center">1000 0001</td></tr><tr><td style="text-align:center"> …</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr><tr><td style="text-align:center"> -1</td><td style="text-align:center">255</td><td style="text-align:center">1111 1111</td></tr><tr><td style="text-align:center"> 0</td><td style="text-align:center">0</td><td style="text-align:center">0000 0000</td></tr></tbody></table><p>补码没有+0/-0之分,所以这个特殊的数就用-128来表示.<br>就像钟表例子一样,这就是一个环,超出之后其实又从0开始计算超出的部分.</p><p>用模来算的话 :<br>八位二进制的模 : 1 0000 0000;<br>-128的绝对值 : 1 000 0000<br>-128的补码 : 10000 0000 - 1000 0000 = 1000 0000  </p><p>负数的补码等于反码加一<br>=&gt; 1 0000 0000 - 1000 0000<br>=&gt; (1111 1111 - 0000 0001) - 1000 0000<br>=&gt; 1111 1111 - 1000 0000 + 1<br>=&gt; 0111 1111 + 1  </p><h2 id="3-3-补码转换为十进制"><a href="#3-3-补码转换为十进制" class="headerlink" title="3.3 补码转换为十进制"></a>3.3 补码转换为十进制</h2><p>负数 =&gt; 对补码再取补  </p><p>[X]<sup>补 = 1101 0010<br>X = [[X]<sup>补</sup>]<sup>补</sup> = [1101 0010]<sup>补</sup> = 1010 1110 = -46  </sup></p><hr><p>B , Binary (二进制);<br>H , Hex (十六进制);<br>O , Octal (八进制);<br>D , Decimal (十进制).  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;正数&lt;sup&gt;原&lt;/sup&gt; = 正数&lt;sup&gt;反&lt;/sup&gt; = 正数&lt;sup&gt;补&lt;/sup&gt;&lt;br&gt;负数&lt;sup&gt;反&lt;/sup&gt; = 负数&lt;sup&gt;原&lt;/sup&gt;　符号位不变,其余按位取反&lt;br&gt;负数&lt;sup&gt;补&lt;/sup&gt; = 负数&lt;sup&gt;
      
    
    </summary>
    
    
  </entry>
  
</feed>
